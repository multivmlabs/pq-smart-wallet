#![cfg_attr(not(any(test, feature = "export-abi")), no_main)]
extern crate alloc;

use alloy_sol_types::sol;
use ml_dsa::{EncodedVerifyingKey, MlDsa65, Signature, VerifyingKey, signature::Verifier};
use stylus_sdk::{abi::Bytes, alloy_primitives::FixedBytes, prelude::*};

sol! {
    error InvalidPublicKey();
    error InvalidSignature();
}

#[derive(SolidityError)]
pub enum VerifierError {
    InvalidPublicKey(InvalidPublicKey),
    InvalidSignature(InvalidSignature),
}

sol_storage! {
    #[entrypoint]
    pub struct MLDSAVerifier {}
}

#[public]
impl MLDSAVerifier {
    /// Verifies an ML-DSA-65 signature.
    ///
    /// Solidity ABI: `verify(bytes calldata, bytes32, bytes calldata) returns (bool)`
    pub fn verify(
        &self,
        public_key: Bytes,
        message: FixedBytes<32>,
        signature: Bytes,
    ) -> Result<bool, VerifierError> {
        let encoded_pubkey: EncodedVerifyingKey<MlDsa65> = public_key
            .0
            .as_ref()
            .try_into()
            .map_err(|_e| VerifierError::InvalidPublicKey(InvalidPublicKey {}))?;

        let vk = VerifyingKey::<MlDsa65>::decode(&encoded_pubkey);
        let signature = Signature::<MlDsa65>::try_from(signature.as_ref())
            .map_err(|_e| VerifierError::InvalidSignature(InvalidSignature {}))?;
        Ok(vk.verify(&message.0, &signature).is_ok())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use ml_dsa::{KeyGen, signature::Signer};
    use stylus_sdk::alloy_primitives::U256;

    fn new_verifier() -> MLDSAVerifier {
        let vm = stylus_test::TestVM::new();
        unsafe {
            MLDSAVerifier::new(
                U256::ZERO,
                0,
                stylus_sdk::host::VM {
                    host: alloc::boxed::Box::new(vm),
                },
            )
        }
    }

    fn test_keypair_and_sig() -> (Vec<u8>, [u8; 32], Vec<u8>) {
        let mut rng = rand::rng();
        let kp: ml_dsa::KeyPair<MlDsa65> = MlDsa65::key_gen(&mut rng);
        let msg = [0xAB_u8; 32];
        let sig = kp.signing_key().sign(&msg);
        let pk_encoded = kp.verifying_key().encode();
        let sig_encoded = sig.encode();
        let pk_bytes: &[u8] = pk_encoded.as_ref();
        let sig_bytes: &[u8] = sig_encoded.as_ref();
        (pk_bytes.to_vec(), msg, sig_bytes.to_vec())
    }

    #[test]
    fn valid_signature_returns_true() {
        let (pk, msg, sig) = test_keypair_and_sig();
        let verifier = new_verifier();
        let result = verifier.verify(Bytes(pk.into()), FixedBytes(msg), Bytes(sig.into()));
        assert!(matches!(result, Ok(true)));
    }

    #[test]
    fn invalid_signature_returns_false() {
        let (pk, msg, mut sig) = test_keypair_and_sig();
        sig[0] ^= 0xFF;
        let verifier = new_verifier();
        let result = verifier.verify(Bytes(pk.into()), FixedBytes(msg), Bytes(sig.into()));
        assert!(matches!(result, Ok(false)));
    }

    #[test]
    fn wrong_length_pk_reverts() {
        let (_, msg, sig) = test_keypair_and_sig();
        let verifier = new_verifier();
        let result = verifier.verify(
            Bytes(vec![0u8; 100].into()),
            FixedBytes(msg),
            Bytes(sig.into()),
        );
        assert!(result.is_err());
    }

    /// Cross-implementation test: verify a signature generated by
    /// @noble/post-quantum v0.5.4 (JS) using ml-dsa v0.1.0-rc.7 (Rust).
    /// This is the critical compatibility boundary for the full E2E flow.
    #[test]
    fn js_noble_signature_verifies_in_rust() {
        #[derive(serde::Deserialize)]
        #[serde(rename_all = "camelCase")]
        struct Vectors {
            public_key: String,
            message: String,
            signature: String,
        }

        let fixture_path = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("test-vectors/js-noble-vectors.json");
        let json = std::fs::read_to_string(&fixture_path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {e}", fixture_path.display()));
        let vectors: Vectors = serde_json::from_str(&json).unwrap();

        let pk = hex::decode(vectors.public_key.trim_start_matches("0x")).unwrap();
        let msg_bytes = hex::decode(vectors.message.trim_start_matches("0x")).unwrap();
        let sig = hex::decode(vectors.signature.trim_start_matches("0x")).unwrap();

        assert_eq!(pk.len(), 1952, "public key size mismatch");
        assert_eq!(sig.len(), 3309, "signature size mismatch");
        assert_eq!(msg_bytes.len(), 32, "message size mismatch");

        let mut msg = [0u8; 32];
        msg.copy_from_slice(&msg_bytes);

        let verifier = new_verifier();
        let result = verifier.verify(Bytes(pk.into()), FixedBytes(msg), Bytes(sig.into()));
        match result {
            Ok(true) => {} // Success â€” noble and ml-dsa agree on FIPS 204
            Ok(false) => panic!("JS noble signature REJECTED by Rust ml-dsa (verify returned false)"),
            Err(_) => panic!("JS noble signature caused decode error in Rust ml-dsa"),
        }
    }
}
